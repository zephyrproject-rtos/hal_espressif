#!/usr/bin/python3
# Copyright (c) 2022 Espressif Systems (Shanghai) Co., Ltd.
# SPDX-License-Identifier: Apache-2.0

import os
import sys
import yaml
import argparse
from pathlib import Path

file_head = '''
/*
 * Copyright (c) 2022 Espressif Systems (Shanghai) Co., Ltd.
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * NOTE: Autogenerated file using esp_genpinctrl.py
 */

#include <dt-bindings/pinctrl/esp32-pinctrl.h>
#include <dt-bindings/pinctrl/esp{SOC}-gpio-sigmap.h>

/ {
\tsoc {
\t\tpinctrl: pin-controller {\n
'''

file_tail = '\t\t};\n\t};\n};\n'

file_name = 'esp32-pinctrl.dtsi'

path_temp = 'temp.dtsi'

line_comment = ''

bias_lut = {
        'pull_up': 'bias-pull-up',
        'pull_down': 'bias-pull-down'
}

outm_lut = {
        'open_drain': 'drive-open-drain',
        'push_pull': 'drive-push-pull'
}

func_lut = {
        'out': 'output-enable',
        'out_low': 'output-low',
        'out_high': 'output-high',
        'in': 'input-enable'
}

def err(source, msg):
    os.remove(path_temp)
    sys.exit('ERR(' + source + '):' + msg)

def get_pin_ios(group_info):
    ios = []
    if 'pins' in group_info:
        pins = group_info['pins']
        for io in pins:
            if type(io) is int:
                ios.append(io)
            elif type(io) is list and io.__len__() == 2:
                for io_num in range(io[0], 1 + io[1]):
                    ios.append(io_num)
            else:
                err('gpio', 'bad type / wrong list size')
    else:
        err('pins', 'missing property')

    return ios

def get_gpio_groups(pin_info):
    if 'gpio' in pin_info:
        return pin_info.get('gpio')
    else:
        err('gpio', 'missing property')

def get_pin_bias(io_group_info):
    bias = ''
    if 'bias' in io_group_info:
        if io_group_info['bias'] in bias_lut:
            return bias_lut[io_group_info['bias']]
        else:
            err('bias', 'unsupported value')
    else:
        bias = ''

    return bias

def get_pin_outm(io_group_info):
    outm = ''
    if 'outm' in io_group_info:
        if io_group_info['outm'] in outm_lut:
            return outm_lut[io_group_info['outm']]
        else:
            err('outm', 'unsupported value')
    else:
        outm = ''

    return outm

def get_pin_sigi(pin_info):
    sigi = 'ESP_'
    if 'sigi' in pin_info:
        sigi = sigi + pin_info['sigi'].upper()
    else:
        sigi = sigi + 'NOSIG'

    return sigi

def get_pin_sigo(pin_info):
    sigo = 'ESP_'
    if 'sigo' in pin_info:
        sigo = sigo + pin_info['sigo'].upper()
    else:
        sigo = sigo + 'NOSIG'

    return sigo

def get_pin_func(pin_info):
    func = []
    if 'func' in pin_info:
        for f in pin_info['func']:
            if f in func_lut:
                func.append(func_lut[f])
            else:
                err('func', 'unsupported value')
    else:
        err('func', 'missing property')

    func = sorted(func)
    return func

def get_pin_state(dev_name, pin_name, pin_info, io, io_group_info):
    bias = get_pin_bias(io_group_info)
    outm = get_pin_outm(io_group_info)
    sigi = get_pin_sigi(pin_info)
    sigo = get_pin_sigo(pin_info)
    func = get_pin_func(pin_info)
    global line_comment
    
    state = dev_name + '_' + pin_name + '_gpio' + str(io)
    state = '\t\t\t' + state + ': ' + state + ' {\n'
    state = state + '\t\t\t\tpinmux = <ESP32_PINMUX(' + str(io) + ', ' + sigi + ', ' + sigo + ')>;\n'
    if bool(bias):
        state = state + '\t\t\t\t' + bias + ';\n'
    if bool(outm):
        state = state + '\t\t\t\t' + outm + ';\n'
    for f in func:
        state = state + '\t\t\t\t' + f + ';\n'
    state = state + '\t\t\t};\n\n'
    if bool(line_comment):
        state = '\t\t\t' + line_comment + state
        line_comment = ''

    return state

def main(data_path):
    path_in = data_path / 'pinctrl.yaml'
    stream = open(path_in, 'r')
    all_data = yaml.load(stream, Loader=yaml.FullLoader)
    soc = os.path.basename(data_path)

    file_out = 'esp' + soc + '-pinctrl.dtsi'
    path_out = data_path / file_out

    # sorts by dev name, which keeps git
    # diffs minimal and easily trackable
    all_data = sorted(all_data.items())

    global path_temp
    path_temp = data_path / path_temp
    f = open(path_temp, 'w')
    f.write(file_head.replace('{SOC}', soc))

    for (dev_name, dev_info) in all_data:

        # sorts by pin name, which keeps git
        # diffs minimal and easily trackable
        dev_info = sorted(dev_info.items())

        for (pin_name, pin_info) in dev_info:
            global line_comment
            line_comment = '/* ' + dev_name.upper() + '\'s ' + pin_name.upper() + ' pin states */\n'
            gpio_groups = get_gpio_groups(pin_info)
            for io_group_name in gpio_groups.keys():
                io_group_info = gpio_groups[io_group_name]
                pin_ios = get_pin_ios(io_group_info)
                for io in pin_ios:
                    state = get_pin_state(dev_name, pin_name, pin_info, io, io_group_info)
                    f.write(state)

    f.write(file_tail)
    f.close()
    os.remove(path_out)
    os.rename(path_temp, path_out)

if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument(
            '-p',
            '--path',
            type=Path,
            required=True,
            help='Path to target file',
    )
    args = parser.parse_args()

    main(args.path)
